#include "allegro.h"
#include <math.h>

BITMAP *backbuffer;

struct Vector
{
	float x, y;
};
struct Edge
{
	struct Vector *s, *e; // start & end - not really necessary, but makes code easier to follow
	struct Vector Normal;
	float Distance; // NB: stored negative, i.e. x*Normal.x + y*Normal.y + Distance = 0 implied (x,y) is on this edge
};
struct Polygon
{
	int NumEdges;
	struct Vector *Corners;
	struct Edge *Edges;
	float ScreenX, ScreenY;
};

#define CIRC_RADIUS 10

void DrawPolygon(struct Polygon *p, int DoPoints)
{
#define Vertex(v1) (int)(p->ScreenX+p->Corners[v1].x), (int)(p->ScreenY+p->Corners[v1].y)

#define DrawEdge(v1, v2)\
	line(backbuffer, Vertex(v1), Vertex(v2), makecol(255, 255, 255));

	int c = p->NumEdges-1;
	DrawEdge(c, 0);
	while(c--)
		DrawEdge(c, c+1);

	if(!DoPoints) return;
	c = p->NumEdges;
	while(c--)
		circle(backbuffer, Vertex(c), CIRC_RADIUS, makecol(255, 0, 0));
	circle(backbuffer, (int)p->ScreenX, (int)p->ScreenY, CIRC_RADIUS, makecol(0, 0, 255));

#undef Vertex
#undef DrawEdge
}

void SeedEdge(struct Edge *e, struct Vector *p1, struct Vector *p2)
{
	float len;
	e->s = p1;
	e->e = p2;

	e->Normal.x = p2->y - p1->y;
	e->Normal.y = p1->x - p2->x;
	len = 1.0f / sqrt(e->Normal.x*e->Normal.x + e->Normal.y*e->Normal.y);
	e->Normal.x *= len;
	e->Normal.y *= len;

	e->Distance = -(p1->x*e->Normal.x + p1->y*e->Normal.y);
}

void FixEdges(struct Polygon *NewP)
{
	int c = NewP->NumEdges;
	while(c--)
		SeedEdge(&NewP->Edges[c], &NewP->Corners[c], &NewP->Corners[(c+1)%NewP->NumEdges]);
}

struct Polygon *GetQuad(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
{
	struct Polygon *NewP = (struct Polygon *)malloc(sizeof(struct Polygon));
	NewP->Corners = (struct Vector *)malloc(sizeof(Vector)*4);
	NewP->Edges = (struct Edge *)malloc(sizeof(struct Edge)*4);
	NewP->NumEdges = 4;

	NewP->Corners[0].x = x1; NewP->Corners[0].y = y1;
	NewP->Corners[1].x = x2; NewP->Corners[1].y = y2;
	NewP->Corners[2].x = x3; NewP->Corners[2].y = y3;
	NewP->Corners[3].x = x4; NewP->Corners[3].y = y4;

	FixEdges(NewP);

	return NewP;
}

void FreePolygon(struct Polygon *p)
{
	free(p->Corners);
	free(p->Edges);
	free(p);
}

void FixDistances(struct Polygon *NewP)
{
	int c = NewP->NumEdges;
	while(c--)
		NewP->Edges[c].Distance = -(NewP->Edges[c].Normal.x*NewP->Corners[c].x + NewP->Edges[c].Normal.y*NewP->Corners[c].y);
}

struct Polygon *GetSum(struct Polygon *a, struct Polygon *b)
{
	int *ExpandedEdges;
	int c, ic;
	int Farthest;
	float FarDist, NewDist;
	struct Polygon *NewP;
	int MaxEdges;

	/*

		RECALL: we want to act as though b has been negatived, so values taken
		from b are negatived

	*/

	/* allocate some memory for temporary store of farthest points */
	ExpandedEdges = (int *)malloc(sizeof(int)*a->NumEdges);

	/* determine farthest points of -b from each edge of a */
	c = a->NumEdges;
	while(c--)
	{
		Farthest = -1;
		FarDist = 0;

		ic = b->NumEdges;
		while(ic--)
		{
			/* normal distance from a line stuff (ax + by + c = 0) - note that because all values
			calculated here will only be compared to each other there is no point adding the constant */
			NewDist = (-b->Corners[ic].x)*a->Edges[c].Normal.x + (-b->Corners[ic].y)*a->Edges[c].Normal.y;

			if((NewDist > FarDist) || (Farthest < 0))
			{
				FarDist = NewDist;
				Farthest = ic;
			}
		}
		ExpandedEdges[c] = Farthest;
	}

	/* allocate memory for polygon - note that if either a or b are non-convex then this may
	well not be enough memory, which will cause a buffer overrun! */
	NewP = (struct Polygon *)malloc(sizeof(struct Polygon));
	MaxEdges = a->NumEdges + b->NumEdges;
	NewP->Corners = (struct Vector *)malloc(sizeof(struct Vector)*MaxEdges);
	NewP->Edges = (struct Edge *)malloc(sizeof(struct Edge)*MaxEdges);

	/* we will use NumEdges to count the current edge in this code */
	NewP->NumEdges = 0;
	for(c = 0; c < a->NumEdges; c++)
	{
		/* add point generated by pushing the edge of a out according to the farthest point of -b */
		NewP->Corners[NewP->NumEdges].x = a->Edges[c].s->x + (-b->Corners[ ExpandedEdges[c] ].x);
		NewP->Corners[NewP->NumEdges].y = a->Edges[c].s->y + (-b->Corners[ ExpandedEdges[c] ].y);

		/* if we're pushing out an edge from a, we'll get an edge with the same normal as a */
		NewP->Edges[NewP->NumEdges].Normal.x = a->Edges[c].Normal.x;
		NewP->Edges[NewP->NumEdges].Normal.y = a->Edges[c].Normal.y;
		NewP->NumEdges++;

		/* add intermediate points if necessary. This is not necessary if the next edge's farthest
		point is the same as this one  */
		if(ExpandedEdges[c]  != ExpandedEdges[(c+1)%a->NumEdges])
		{
			ic = ExpandedEdges[c];
			while(ic != ExpandedEdges[(c+1)%a->NumEdges])
			{
				/* intermediate points are always offsets of intermediates from -b added to the end
				vertex of a */
				NewP->Corners[NewP->NumEdges].x = a->Edges[c].e->x + (-b->Corners[ ic ].x);
				NewP->Corners[NewP->NumEdges].y = a->Edges[c].e->y + (-b->Corners[ ic ].y);

				/* as geometry is now coming directly from -b, give or take an offset in space, so
				normals must too */
				NewP->Edges[NewP->NumEdges].Normal.x = -b->Edges[ic].Normal.x;
				NewP->Edges[NewP->NumEdges].Normal.y = -b->Edges[ic].Normal.y;

				NewP->NumEdges++;
				ic = (ic+1)%b->NumEdges;
			}
		}
	}

	/* although we've correctly duplicated all edge normals, we haven't worked out their correct
	distances from the origin - do that now */
	FixDistances(NewP);

	free(ExpandedEdges);
	return NewP;
}

struct Vector *GrabCorner(struct Polygon *P, float x, float y)
{
	float Dist, DiffX, DiffY;
	int c = P->NumEdges;
	while(c--)
	{
		DiffX = (x - P->ScreenX) - P->Corners[c].x;
		DiffY = (y - P->ScreenY) - P->Corners[c].y;
		Dist = DiffX*DiffX + DiffY*DiffY;
		if(Dist < CIRC_RADIUS*CIRC_RADIUS)
			return &P->Corners[c];
	}
	return NULL;
}

int Contained(struct Polygon *P, float x, float y)
{
	int c = P->NumEdges;
	while(c--)
		if((x*P->Edges[c].Normal.x + y*P->Edges[c].Normal.y + P->Edges[c].Distance) > 0) return FALSE;

	return TRUE;
}

int main(int argc, const char *argv[])
{
	int quit = FALSE;
	int fixpolys = TRUE;
	struct Polygon *Q1, *Q2, *Sum = NULL;

	struct Vector *MouseGrabVector = NULL;
	struct Polygon *MouseGrabPolygon = NULL;

	allegro_init();
	install_keyboard();
	install_mouse();
	set_color_depth(desktop_color_depth());
	if (set_gfx_mode(GFX_AUTODETECT_WINDOWED, 640, 480, 0, 0)) {
		allegro_message("Error setting 320x200x8 gfx mode:\n%s\n", allegro_error);
		return -1;
	}
	backbuffer = create_bitmap(SCREEN_W, SCREEN_H);

	Q1 = GetQuad(-25, -25, 25, -25, 25, 25, -25, 25); Q1->ScreenX = 50; Q1->ScreenY = 50;
	Q2 = GetQuad(-25, -25, 25, -25, 45, 25, -25, 25); Q2->ScreenX = 50; Q2->ScreenY = 150;

	while(!quit)
	{
		show_mouse(backbuffer);
		blit(backbuffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
		show_mouse(NULL);
		clear_to_color(backbuffer, 0);

		if(mouse_b)
		{
			if(MouseGrabPolygon)
			{
				if(MouseGrabVector)
				{
					MouseGrabVector->x = mouse_x - MouseGrabPolygon->ScreenX;
					MouseGrabVector->y = mouse_y - MouseGrabPolygon->ScreenY;
					FixEdges(MouseGrabPolygon);
				}
				else
				{
					MouseGrabPolygon->ScreenX = mouse_x;
					MouseGrabPolygon->ScreenY = mouse_y;
				}
			}
			else
			{
				float DiffX, DiffY, Dist;

				/* decide what we hit */
				if(MouseGrabVector = GrabCorner(Q1, (float)mouse_x, (float)mouse_y))
				{
					MouseGrabPolygon = Q1;
				}
				else
					if(MouseGrabVector = GrabCorner(Q2, (float)mouse_x, (float)mouse_y))
					{
						MouseGrabPolygon = Q2;
					}

				if(!MouseGrabVector)
				{
					DiffX = mouse_x - Q1->ScreenX;
					DiffY = mouse_y - Q1->ScreenY;
					Dist = DiffX*DiffX + DiffY*DiffY;
					if(Dist < CIRC_RADIUS*CIRC_RADIUS)
						MouseGrabPolygon = Q1;
					else
					{
						DiffX = mouse_x - Q2->ScreenX;
						DiffY = mouse_y - Q2->ScreenY;
						Dist = DiffX*DiffX + DiffY*DiffY;
						if(Dist < CIRC_RADIUS*CIRC_RADIUS)
							MouseGrabPolygon = Q2;
					}
				}
			}
		}
		else
		{
			MouseGrabPolygon = NULL;
			MouseGrabVector = NULL;
		}

		Sum = GetSum(Q1, Q2);
		if(Sum)
		{
			textprintf_ex(backbuffer, font, 0, 8, makecol(255, 255, 255), -1, "Sum: %d points", Sum->NumEdges);

			Sum->ScreenX = 320;
			Sum->ScreenY = 240;
			DrawPolygon(Sum, FALSE);

			if(fixpolys)
			{
				float CollX, CollY;
				CollX = Q2->ScreenX - Q1->ScreenX;
				CollY = Q2->ScreenY - Q1->ScreenY;

				if(Contained(Sum, CollX, CollY))
				{
					/* just find the edge that runs closest to the origin - given that Sum is convex
					we needn't worry about line segments but can just deal in the infinite stuff */
					int Closest = -1;
					float CloseDist = 1;
					int c = Sum->NumEdges;
					while(c--)
					{
						float Dist = Sum->Edges[c].Normal.x*CollX + Sum->Edges[c].Normal.y*CollY + Sum->Edges[c].Distance;
						if(Dist > CloseDist || Closest < 0)
						{
							Closest = c;
							CloseDist = Dist;
						}
					}

					/* push whichever the mouse is not pushing */
					if(MouseGrabPolygon == Q2)
					{
						Q1->ScreenX += CloseDist*Sum->Edges[Closest].Normal.x;
						Q1->ScreenY += CloseDist*Sum->Edges[Closest].Normal.y;
					}
					else
					{
						Q2->ScreenX -= CloseDist*Sum->Edges[Closest].Normal.x;
						Q2->ScreenY -= CloseDist*Sum->Edges[Closest].Normal.y;
					}
				}
			}

			FreePolygon(Sum);
		}
		DrawPolygon(Q1, TRUE);
		DrawPolygon(Q2, TRUE);

		circle(backbuffer, (int)(320 + (Q2->ScreenX - Q1->ScreenX)), (int)(240 + (Q2->ScreenY - Q1->ScreenY)), CIRC_RADIUS, makecol(0, 255, 0));
		textprintf_ex(backbuffer, font, 0, 0, makecol(255, 255, 255), -1, "%s overlap (Q/W to toggle)", fixpolys ? "Preventing" : "Allowing" );

		if(key[KEY_ESC]) quit = TRUE;
		if(key[KEY_W]) fixpolys = TRUE;
		if(key[KEY_Q]) fixpolys = FALSE;
	}

	FreePolygon(Q1);
	FreePolygon(Q2);
	return 0;
}
END_OF_MAIN();
